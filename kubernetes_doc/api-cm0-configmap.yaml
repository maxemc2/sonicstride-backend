apiVersion: v1
data:
  config.py: |-
    from pydantic_settings import BaseSettings
    import os

    class Setting(BaseSettings):
        # Database config
        database_url: str
        database_name: str
        database_user: str
        database_password: str
        database_port: str

    # path = os.getenv("../.env")
    # setting = Setting(_env_file=path, _env_file_encoding="utf-8")
    setting = Setting()
  database.py: |-
    from sqlalchemy import create_engine
    from sqlalchemy.ext.declarative import declarative_base
    from sqlalchemy.orm import sessionmaker
    # Local Application Imports
    from config import setting

    # Format the SQLAlchemy database URL
    SQLALCHEMY_DATABASE_URL = (
        f"postgresql://{setting.database_user}:{setting.database_password}"
        f"@{setting.database_url}:5432/{setting.database_name}"
    )

    # Create a SQLAlchemy engine instance which provides a source of connectivity to our database
    engine = create_engine(SQLALCHEMY_DATABASE_URL)

    # Create a factory for SQLAlchemy session instances that are bound to our database engine
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

    # Create the declarative base model that other models will inherit from
    # This is a class that includes directives to describe the actual database table it will be mapped to
    Base = declarative_base()
  main.py: "from fastapi import FastAPI, Depends, Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.middleware.cors import CORSMiddleware  # Fixed typo in 'CORSMiddleware'\nfrom loguru import logger\nimport os\nimport time\nimport datetime\n# Local Application Imports\nfrom database import Base, engine\nimport endpoint as endpoint\n\n# Create tables in the database (if they don't exist already)\nBase.metadata.create_all(bind=engine)\n\napp = FastAPI(title=\"Sonicstride 音樂存取\")\n\n# Adding CORS middleware to allow cross-origin requests\napp.add_middleware(\n    CORSMiddleware,  # Fixed typo in 'CORSMiddleware'\n    allow_origins=[\"*\"],  # Allow all origins\n    allow_credentials=True,  # Allow credentials such as cookies\n    allow_methods=[\"*\"],  # Allow all HTTP methods\n    allow_headers=[\"*\"],  # Allow all headers\n)\n\n# Setting the timezone to Asia/Taipei\nos.environ[\"TZ\"] = \"Asia/Taipei\"\ntime.tzset()\n\n# Configuring logger to create a new log file daily at midnight, \n# with UTF-8 encoding, and retaining logs for 30 days\nlogger.add(\n    \"./logs/{time}.log\",  # Log file path\n    rotation=datetime.time(0, 0, 0),  # Rotate daily at midnight\n    encoding=\"utf-8\",  # File encoding\n    retention=\"30 days\",  # Keep logs for 30 days\n    level=\"DEBUG\",  # Log level\n)\n\n# Asynchronous function to log incoming requests\nasync def log_request(request: Request):\n    logger.info(f\"[{request.client.host}] {request.method} {request.url}\")\n\n# Including the router from the endpoint module and adding log_request as a dependency\napp.include_router(endpoint.ROUTER, dependencies=[Depends(log_request)])\n\n# Middleware to limit file upload size to 100MB\n@app.middleware(\"http\")\nasync def limit_upload_size(request, call_next):\n    if request.url.path == \"/api/music/upload\" and request.method == \"POST\":\n        content_length = request.headers.get('content-length')\n        if content_length and int(content_length) > 100 * 1024 * 1024:  # 100MB limit\n            return JSONResponse(content={\"detail\": \"File too large\"}, status_code=413)\n    return await call_next(request)"
  model.py: |-
    from enum import Enum
    from uuid import uuid4
    from datetime import datetime
    from sqlalchemy import Column, String, Integer, DateTime, Enum as SQLAlchemyEnum
    from sqlalchemy.dialects.postgresql import UUID
    # Local Application Imports
    from database import Base

    # Enum for default scene
    class SceneEnum(str, Enum):
        Running = 'Running'
        Walking = 'Walking'
        NULL = 'NULL'

    # Enum for music genres
    class GenreEnum(str, Enum):
        Ambient = 'Ambient'
        Nature_Sounds = 'Nature Sounds'
        Instrumental = 'Instrumental'
        Lofi = 'Lofi'
        Classical = 'Classical'
        Jazz = 'Jazz'
        Electronic = 'Electronic'
        Meditative = 'Meditative'
        Binaural_Beats = 'Binaural Beats'
        ASMR = 'ASMR'
        Chillhop = 'Chillhop'
        Soundscapes = 'Soundscapes'
        World_Music = 'World Music'
        Folk = 'Folk'
        Rain_Sounds = 'Rain Sounds'
        Ocean_Waves = 'Ocean Waves'
        White_Noise = 'White Noise'
        Other = 'other'

    # SQLAlchemy model for the Musics table
    class MusicsModel(Base):
        __tablename__ = 'musics'

        # Unique identifier
        id = Column(UUID(as_uuid=True), primary_key=True, default=uuid4, unique=True, nullable=False)
        # Title of the experiment
        experiment_title = Column(String, nullable=False)
        # Default scene enum
        default_scene = Column(SQLAlchemyEnum(SceneEnum), nullable=False)
        # Genre enum
        genre = Column(SQLAlchemyEnum(GenreEnum), nullable=False)
        # Beats per minute, can be null
        bpm = Column(Integer, nullable=True)
        # Musical key, can be null
        key = Column(String, nullable=True)
        # Name of the song
        song_name = Column(String, nullable=False)
        # Track ID in the format '01A-001-V1'
        track_id = Column(String, nullable=False)
        # Music file path
        music_file = Column(String, nullable=False, default='path/to/music/file.mp3')
        # Upload date, auto set to current date and time
        upload_date = Column(DateTime, default=datetime.utcnow, nullable=False)
kind: ConfigMap
metadata:
  labels:
    io.kompose.service: api
  name: api-cm0
